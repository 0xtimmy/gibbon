
\newcommand{\gramdef}{\; ::= \;}
\newcommand{\gramor}{\; | \;}
\newcommand{\PROG}{\keywd{prog}}
\newcommand{\EXPR}{\keywd{e}}
% \newcommand{\PRIM}{\keywd{\rho}}
\newcommand{\PRIM}{\odot}
\newcommand{\TYP}{\keywd{\tau}}
\newcommand{\ARROW}{\rightarrow}
\newcommand{\DD}{\keywd{dd}}
\newcommand{\VD}{\keywd{vd}}
\newcommand{\FD}{\keywd{fd}}
\newcommand{\TC}{\keywd{T}}
\newcommand{\DC}{\keywd{K}}

\ifcurly
\newcommand{\DATA}{\gramwd{type}}
\else
\newcommand{\DATA}{\gramwd{data}}
\fi

\newcommand{\sDC}{\skeywd{K}}
\newcommand{\sTYP}{\skeywd{\tau}}
\newcommand{\sEXPR}{\skeywd{e}}
\newcommand{\NEEDS}[2]{\, Needs(#1,#2)}
\newcommand{\HAS}[1]{\, Has(#1)}

% \newcommand{\ENDSYM}{\, EndOf}
\newcommand{\ENDSYM}{\, End}
\newcommand{\ENDOF}[1]{\, \ENDSYM(\locend{#1})}
\newcommand{\TOEND}[1]{\gramwd{toEnd}(#1)}
\newcommand{\FROMEND}[1]{\gramwd{fromEnd}(#1)}
\newcommand{\WRITETAG}[2]{\gramwd{write}(#1,#2)}
\newcommand{\WRITENUM}[2]{\gramwd{write}(#1,#2)}
\newcommand{\FINISH}[1]{\gramwd{finish}(#1)}
\newcommand{\READTAG}[1]{\gramwd{read}(#1)}

\newcommand{\STARTV}[1]{\gramwd{start}(#1)}
\newcommand{\ENDV}[1]{\gramwd{end}(#1)}

\newcommand{\skeywd}[1]{#1}
\newcommand{\keywd}[1]{\; {#1} \;}
\newcommand{\keywdr}[1]{\; {#1}_1 \ldots {#1}_n \;}
\newcommand{\gramwd}[1]{\; \texttt{#1} \;}
\newcommand{\sgramwd}[1]{\texttt{#1}}
\newcommand{\sumtype}[2]{\; {#1} \; + \; {#2} \;}
\newcommand{\pairtype}[2]{\; {#1}, {#2} \;}
\newcommand{\dicttype}[1]{\; dictionary(#1)\;}
\ifcurly
\newcommand{\case}[2]{\gramwd{match}\; #1\; \gramwd{of}\; #2 \;}
\else
\newcommand{\case}[2]{\gramwd{case}\; #1\; \gramwd{of}\; #2 \;}
\fi
\newcommand{\pcasesym}{\gramwd{switch}}
\newcommand{\pcase}[2]{\pcasesym{}\; #1\; \gramwd{of}\; #2 \;}
\newcommand{\pair}[2]{\; ({#1} \,,\, {#2}) \;}
\newcommand{\fst}[1]{\; \gramwd{fst} \; {#1} \;}
\newcommand{\snd}[1]{\; \gramwd{snd} \; {#1} \;}
\newcommand{\bind}[2]{{#1} \Rightarrow {#2}}
\newcommand{\inl}[1]{\; \gramwd{inl} \; #1 \;}
\newcommand{\inr}[1]{\; \gramwd{inr} \; #1 \;}
\newcommand{\fun}[2]{\; \lambda {#1} . {#2} \;}
\newcommand{\var}{\; \svar \;}
\newcommand{\svar}{v}
\newcommand{\fvar}{\; \sfvar \;}
\newcommand{\sfvar}{f}
\newcommand{\num}{\; n \;}
\newcommand{\primexpr}[1]{\; \PRIM(#1) \;}
\newcommand{\letexpr}[3]{\;\gramwd{let} \; #1 = #2 \; \gramwd{in} \; #3 \;}
% \newcommand{\ife}[3]{\; \gramwd{if}\; #1 #2 #3 \;}
\newcommand{\ife}[3]{\gramwd{if} #1 \gramwd{then} #2 \gramwd{else} #3}
\newcommand{\app}[2]{\; #1 #2 \;}

%% \begin{figure}
%% \hspace{-0.05\textwidth}
%% \begin{minipage}{1.06\textwidth}
%%   \begin{minipage}{.66\textwidth}

\begin{figure}
    \begin{displaymath}
    \DC \in \; \textup{Data Constructors}, \:\: \TC \in \; \textup{Type Constructors}, \:\: \var \in \; \textup{Variables}
  \end{displaymath} 
  \begin{displaymath}
    \begin{aligned}
      \textup{Program} && \PROG && \gramdef &
%        \DD_1 \ldots \DD_n \; ; \VD_1 \ldots \VD_m \; ; \FD_1 \ldots \FD_m \; ; \EXPR 
        \overline{\DD} \;; \overline{\VD} \; ; \overline{\FD} \; ; \EXPR 
        \\
      \textup{Packed Data Declarations} && \DD && \gramdef & \DATA \TC = \overline{\DC \; \overline{\sTYP}\;} \\
      \textup{Value Declarations}    && \VD && \gramdef & \var : \TYP  ; \var = \EXPR \\ 
      \textup{Function Declarations} && \FD && \gramdef &
         \fvar : \TYP \ARROW \TYP; 
         \fvar({\var}) = \EXPR \\ 
      \textup{Expressions} && \EXPR && \gramdef & \var \gramor \num \gramor \gramwd{True} \gramor \gramwd{False}
%      \gramor \primexpr{\overline{\sEXPR}}
      \gramor \sEXPR \PRIM \sEXPR
      \gramor 
% FIRST ORDER version:
       \app{f}{\sEXPR} \\
% HIGHER ORDER version:
%      \app{\EXPR}{\sEXPR} \gramor \fun{\var:\TYP}{\EXPR} \\
%
      && && \gramor & 
      %    \pair{\sEXPR}{\sEXPR} \gramor \fst{e} \gramor \snd{e}
      \;(e_1,\, \dots\, , e_n) \gramor \EXPR.\num 
      \gramor \letexpr{\var:\TYP}{\EXPR}{\EXPR} \\
      && && \gramor & \case{\sEXPR}{\overline{\bind{\DC \; \overline{\svar} \;}{\EXPR}}} 
            \gramor  \ife{\EXPR}{\EXPR}{\EXPR} \\
      \textup{Types} && \TYP && \gramdef &
         \TC \gramor
         \;(\TYP_1,\, \dots\, , \TYP_n)
         % \pairtype{\TYP}{\TYP} 
         % \gramor \TYP \ARROW \TYP
         \gramor \gramwd{Int} \gramor \gramwd{Bool} \gramor \dots
      \\
      %% && && \gramor & \NEEDS{[\overline{\sTYP}]}{\sTYP} \gramor \HAS{\sTYP} \\
      \textup{Prim Ops} && \PRIM && \gramdef & + \gramor - \gramor * \gramor \ldots \\
    \end{aligned}
  \end{displaymath}
   \vspace{-4mm}
  \caption{Grammar for source language.}
%  \Red{FIXME THIS IS NOT A FIRST-ORDER  LANGUAGE.  It needs top-level fundefs.}
%  \label{fig:gram1}
  \label{fig:source}
\end{figure}

%%   \end{minipage}
%%   \hspace{15mm}
%%   %\begin{figure}
%%   \begin{minipage}{.25\textwidth}
%%     %      \vspace{-30mm}
%%     \vspace{30mm}
%% {
%%   \begin{mathpar}
%%     \inferrule [FINISH]
%%         {\Gamma \vdash \EXPR : \NEEDS{[]}{\sTYP}}
%%         {\Gamma \vdash \EXPR : \HAS{\sTYP}}
%%   \end{mathpar}
%%   \caption{Select rules from  the type system}
%%   \label{fig:types1}
%% }
%% %\end{figure}
%%   \end{minipage}
%% \end{minipage}
%% \end{figure}

\begin{figure}
  \vspace{-5mm}
  \begin{displaymath}
    \begin{aligned}
      \textup{Expressions} && \EXPR && 
     \gramdef & \ldots \gramor \pcase{v}{\overline{\bind{\DC(v)}{\EXPR}}} 
     \gramor  \TOEND{\sEXPR}
     \gramor  \FROMEND{\sEXPR}
     \\     
     && && \gramor & \WRITETAG{`\sDC\textrm'}{\var}
           \gramor \WRITENUM{\num}{\var}
           \gramor \READTAG{\var} \gramor 
      \FINISH{\sEXPR} \\      
      \textup{Types} && \TYP && \gramdef & \ldots 
               \gramor T_{\ell}
               \gramor \NEEDS{[\overline{\sTYP}]}{\sTYP} \gramor \HAS{[\overline{\sTYP}]} 
               \gramor \ENDOF{\ell} \\
      \textup{Extended vars} && \var && \gramdef & 
           \textrm{v} \gramor \gramwd{end}_{\textrm{v}}
             \gramor \gramwd{start}_{\textrm{v}} \\
      \textup{Location vars} && \ell && \gramdef & \alpha \gramor \beta \gramor \ldots \\
    \end{aligned}
  \end{displaymath}
  \vspace{-4mm}
  \caption{Extensions to the core language for cursor-inserting compilation.
    Here we read and write word-sized (or smaller) values from byte streams. And
    switch is a low-level mechanism to read and case on the next tag byte from a
    stream.}
  %  \label{fig:gram2}
  \label{fig:target}
\end{figure}
