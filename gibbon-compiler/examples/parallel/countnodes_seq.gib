#lang gibbon

(require "../../../ASTBenchmarks/grammar_racket.gib")
(provide countnodes)

(define (countnodes [e0 : Toplvl]) : Int
  (top e0))

(define nullcost : Int 1)

(define conscost : Int 1)

(define scalarcost : Int 0)

(define tag : Int 1)


(define (loopTopLvl [ls : ListToplvl]) : Int
  (case ls
    [(CONSTOPLVL tl ls)
     (+ conscost (+ (top tl) (loopTopLvl ls)))]
    [(NULLTOPLVL)
     nullcost]))

(define (loopExpr [ls : ListExpr]) : Int
  (case ls
    [(CONSEXPR e ls)
     (+ conscost (+ (expr e) (loopExpr ls)))]
    [(NULLEXPR)
     nullcost]))

(define (loopLambdaCase [ls : LAMBDACASE]) : Int
  (case ls
    [(CONSLAMBDACASE f le ls)
     (+ conscost (+ (formals f) (+ (loopExpr le) (loopLambdaCase ls))))]
    [(NULLLAMBDACASE)
     nullcost]))

(define (loopLVBIND [ls : LVBIND]) : Int
  (case ls
    [(CONSLVBIND syms e ls)
     (+ conscost (+ (loopSyms syms)
                    (+ (expr e) (loopLVBIND ls))))]
    [(NULLLVBIND)
     nullcost]))

(define (top [e : Toplvl]) : Int
  (case e
    [(DefineValues ls e)
     (+ tag (+ (loopSyms ls) (expr e)))]
    [(DefineSyntaxes ls e)
     (+ tag (+ (loopSyms ls) (expr e)))]
    [(BeginTop ls)
     (+ tag (loopTopLvl ls))]
    [(Expression e)
     (+ tag (expr e))]))

(define (expr [e : Expr]) : Int
  (case e
    ;; Variable references:
    [(VARREF s)
     (+ tag scalarcost)]
    [(Top s)
     (+ tag scalarcost)]
    [(VariableReference s)
     (+ tag scalarcost)]
    [(VariableReferenceTop s)
     (+ tag scalarcost)]
    [(VariableReferenceNull)
     tag]

    ;; Leaf forms:
    [(Quote d)
     (+ tag (datum d))]
    [(QuoteSyntax d)
     (+ tag (datum d))]
    [(QuoteSyntaxLocal d)
     (+ tag (datum d))]

    ;; Binding forms:
    [(Lambda f lse)
     (+ tag (+ (formals f) (loopExpr lse)))]
    [(CaseLambda cases)
     (+ tag (loopLambdaCase cases))]
    [(LetValues binds body)
     (+ tag (+ (loopLVBIND binds)
               (loopExpr body)))]
    [(LetrecValues binds body)
     (+ tag (+ (loopLVBIND binds)
               (loopExpr body)))]
    [(If cond then else)
     (+ tag (+ (expr cond) (+ (expr then) (expr else))))]
    [(Begin exprs)
     (+ tag (loopExpr exprs))]
    [(Begin0 e1 exprs)
     (+ tag (+ (expr e1) (loopExpr exprs)))]
    [(App e1 es)
     (+ tag (+ (expr e1) (loopExpr es)))]
    [(SetBang s e)
     (+ tag (+ scalarcost (expr e)))]
    [(WithContinuationMark e1 e2 e3)
     (+ tag (+ (expr e1) (+ (expr e2) (expr e3))))]))

(define (datum [d : Datum]) : Int
  (case d
    [(INTLIT i)
     (+ tag scalarcost)]))

(define (loopSyms [ls : ListSym]) : Int
  (case ls
    [(CONSSYM s ls)
     (+ conscost (+ scalarcost (loopSyms ls)))]
    [(NULLSYM) nullcost]))

(define (formals [f : Formals]) : Int
  (case f
    [(F1 ls)
     (+ tag (loopSyms ls))]
    [(F2 ls s)
     (+ tag (+ (loopSyms ls) scalarcost))]
    [(F3 s)
     (+ tag scalarcost)]))
