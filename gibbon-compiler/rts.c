#include <assert.h>
#include <stdio.h>
// #include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <sys/mman.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>


// Big default.  Used for --packed and --pointer/bumpalloc
static long long global_default_buf_size = (500lu * 1000lu * 1000lu);

static long long global_size_param = 1;
static long long global_iters_param = 1;

static char*     global_benchfile_param = NULL;

// Sequential for now:
static const int num_workers = 1;


// Helpers and debugging:
//--------------------------------------------------------------------------------

// Requires -std=gnu11
/*int dbgprintf(const char *format, ...)
{
    va_list args;
    va_start(args, format);
#ifdef DEBUG
      vprintf(format, args);
#endif
    va_end(args);
}*/

//--------------------------------------------------------------------------------

#ifdef BUMPALLOC
// #warning "Using bump allocator."
  // Here we use one heap_ptr per thread:
  typedef char* HeapPtr;
  HeapPtr heap_ptr = (HeapPtr)0;

  // An array storing the location of each thread's heap_ptr:
  HeapPtr** heap_addrs;
  HeapPtr* saved_heap_ptrs;
  
  // For simplicity just use a single large slab:
  void INITALLOC() {
    if (! heap_ptr) {
      heap_ptr = (HeapPtr)malloc(global_default_buf_size);
      // printf("Arena size for bump alloc: %lld\n", global_default_buf_size);
      heap_addrs      = (HeapPtr**)calloc(num_workers, sizeof(HeapPtr*));
      saved_heap_ptrs = (HeapPtr*) calloc(num_workers, sizeof(HeapPtr));
    }
    // printf("INIT ALLOC DONE: heap_ptr = %p\n", heap_ptr);
  }

  #ifdef DEBUG
   char* my_abort() {
     fprintf(stderr, "Error: this thread's heap was not initalized.\n");
     abort();
     return NULL;
   }
   #define ALLOC(n) (heap_ptr ? heap_ptr += n : my_abort())
  #else
   #define ALLOC(n) (heap_ptr += n)
  #endif // DEBUG

  // Snapshot the current heap pointer value across all threads.
  void save_alloc_state() {
    // dbgprintf("   Saving(%d): ", num_workers);
    for(int i=0; i<num_workers; i++) {
      saved_heap_ptrs[i] = * heap_addrs[i];
      // dbgprintf("%p ", saved_heap_ptrs[i]);
    }
    // dbgprintf("\n");    
  }

  void restore_alloc_state() {
    // dbgprintf("Restoring(%d): ", num_workers);
    for(int i=0; i<num_workers; i++) {
      *heap_addrs[i] = saved_heap_ptrs[i];
      //dbgprintf("%p ", saved_heap_ptrs[i]);
    }
    //dbgprintf("\n");
  }

#else
  // Regular malloc mode:
  void INITALLOC() {}

  #define ALLOC(n) malloc(n)
//  #define DELTREE deleteTree

#endif // BUMPALLOC

#define ALLOC_PACKED(n) ALLOC(n)

// --------------------------------------------------------------------------------

typedef char TagTyPacked;  // Must be consistent with codegen in Target.hs
typedef char TagTyBoxed;   // Must be consistent with codegen in Target.hs
typedef long long IntTy;
typedef IntTy SymTy;

typedef struct dict_item {
  struct dict_item * next;
  int key;
  union {
    int intval;
    void * ptrval;
  };
} dict_item_t;

dict_item_t * dict_alloc() {
  return ALLOC(sizeof(dict_item_t));
}

dict_item_t *dict_insert_int(dict_item_t *ptr, SymTy key, IntTy val) {
  dict_item_t *ret = dict_alloc();
  ret->key = key;
  ret->intval = val;
  ret->next = ptr;
  return ret;
}

IntTy dict_lookup_int(dict_item_t *ptr, SymTy key) {
  while (ptr != 0) {
    if (ptr->key == key) {
      return ptr->intval;
    } else {
      ptr = ptr->next;
    }
  }
  printf("Error, key %lld not found!\n",key);
  exit(1);
}

char* read_benchfile_param() {
  if (global_benchfile_param == NULL) {
    fprintf(stderr, "read_benchfile_param: benchmark input file was not set!\n");
    exit(1);
  } else
    return global_benchfile_param;
}

// Could try alloca() here.  Better yet, we could keep our own,
// separate stack and insert our own code to restore the pointer
// before any function that (may have) called ALLOC_SCOPED returns.

// #define ALLOC_SCOPED() alloca(1024)
#define ALLOC_SCOPED() alloca(100LU*1024LU)
// #define ALLOC_SCOPED() alloc_scoped()

// Stack allocation is either too small or blows our stack.
// We need a way to make a giant stack if we want to use alloca.
// #define ALLOC_SCOPED() ALLOC(global_default_buf_size)


// Our global pointer.  No parallelism.
// static char* stack_scoped_region;
// char* alloc_scoped() { return stack_scoped_region; }


// fun fact: __ prefix is actually reserved and this is an undefined behavior.
// These functions must be provided by the code generator.
void __main_expr();


void show_usage(char** argv)
{
    printf("\n");
    printf("This binary was generated by the Gibbon compiler.\n");
    printf("\n");
    printf("Usage: %s [OPTS] [size] [iters]\n", argv[0]);
    
    printf("\n");
    printf("Options:\n");
    printf(" --buffer-size <bytes>      Set the buffer size (default %lld).\n", global_default_buf_size);
    printf(" --bench-input <path>       Set the input file read for benchmarking. Applies only\n");
    printf("                            IF the program was *compiled* with --bench-fun. \n");
    return;
}

double avg(const double* arr, int n)
{
    double sum = 0.0;
    for(int i=0; i<n; i++) sum += arr[i];
    return sum / (double)n;
}

double difftimespecs(struct timespec* t0, struct timespec* t1)
{
    return (double)(t1->tv_sec - t0->tv_sec)
      + ((double)(t1->tv_nsec - t0->tv_nsec) / 1000000000.0);
}

int compare_doubles(const void *a, const void *b)
{
    const double *da = (const double *) a;
    const double *db = (const double *) b;
    return (*da > *db) - (*da < *db);
}


int main(int argc, char** argv)
{
    // parameters to parse:
    //
    //   num iterations: How many times to repeat a benchmark. 
    //   tree size: An integer passes to `build_tree()`. 

    struct rlimit lim;
    int code;
    if ( (code = getrlimit(RLIMIT_STACK, &lim)) ) {
      fprintf(stderr, " [gibbon rts] failed to getrlimit, code %d\n", code);
      abort();
    }
    
    // lim.rlim_cur = 1024LU * 1024LU * 1024LU; // 1GB stack.
    lim.rlim_cur = 512LU * 1024LU * 1024LU; // 500MB stack.
    // lim.rlim_max = lim.rlim_cur; // Normal users may only be able to decrease this.

    // WARNING: Haven't yet figured out why this doesn't work on MacOS...
    #ifndef __APPLE__
    code = setrlimit(RLIMIT_STACK, &lim);    
    while (code) {
      fprintf(stderr, " [gibbon rts] Failed to set stack size to %llu, code %d\n", (unsigned long long)lim.rlim_cur, code);
      lim.rlim_cur /= 2;
      // lim.rlim_max /= 2;
      if(lim.rlim_cur < 100 * 1024) {
        fprintf(stderr, " [gibbon rts] Failed setrlimit stack size to something reasonable; giving up.\n");
        break; // abort();
      }
      int code = setrlimit(RLIMIT_STACK, &lim);    
    }
    #endif
    
    // TODO: atoi() error checking
    int i;
    for (i = 1; i < argc; ++i)
    {
        if (strcmp(argv[i], "-h") == 0 || strcmp(argv[i], "--help") == 0) {
          show_usage(argv);
          exit(0);
        }
        else if (strcmp(argv[i], "--buffer-size") == 0 && i < argc - 1)
        {
            global_default_buf_size = atoll(argv[i + 1]);
            i++;
        }
        else if ((strcmp(argv[i], "--bench-input") == 0)) {
	  if (i+1 >= argc) {
            fprintf(stderr, "Not enough arguments after -file, expected <file>.\n");
            show_usage(argv);
            exit(1);
          }
	  global_benchfile_param = argv[i+1];
	  i++;
	}
        else break;
    }
    // If present, we expect the last two arguments to be <size> <iters>
    if (i < argc) {
      global_size_param  = atoll(argv[i]);
      i++;
    }
    if (i < argc) {
      global_iters_param = atoll(argv[i]);
      i++;
    }
    if (i < argc) {
      fprintf(stderr, "Extra arguments left over: ");
      for(; i < argc; i++) fprintf(stderr, "%s ", argv[i]);
      show_usage(argv);
      exit(1);
    }

    INITALLOC();
    __main_expr();

    return 0;
}
