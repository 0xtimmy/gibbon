\title{Gibbon Intermediate Language Design \\ Take Two}
\author{}

\documentclass[12pt]{article}

\usepackage{listings}
\usepackage{url}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{hyperref}
\usepackage{graphicx}
% \usepackage{mathabx}
% \usepackage{mathpartir}
\usepackage{xspace}
\usepackage[noabbrev,capitalise]{cleveref}
\usepackage{enumitem}
\usepackage{wrapfig}
\usepackage[labelformat=simple]{subcaption}

\newcommand{\gramdef}{\; ::= \;}
\newcommand{\gramor}{\; | \;}
\newcommand{\PROG}{\keywd{prog}}
\newcommand{\EXPR}{\keywd{e}}
\newcommand{\PRIM}{\keywd{\rho}}
\newcommand{\TYP}{\keywd{\tau}}
\newcommand{\STYP}{\keywd{\mathcal{T}}}
\newcommand{\ARROW}{\rightarrow}
\newcommand{\DD}{\keywd{dd}}
\newcommand{\VD}{\keywd{vd}}
\newcommand{\FD}{\keywd{fd}}
\newcommand{\TC}{\keywd{T}}
\newcommand{\DC}{\keywd{K}}
\newcommand{\DATA}{\gramwd{data}}
\newcommand{\sDC}{\skeywd{K}}
\newcommand{\sTYP}{\skeywd{\tau}}
\newcommand{\sEXPR}{\skeywd{e}}
\newcommand{\NEEDS}[2]{\; Needs(#1,#2) \;}
\newcommand{\HAS}[1]{\; Has(#1) \;}
\newcommand{\ENDOF}[1]{\; EndOf(#1) \;}
\newcommand{\WRITETAG}[2]{\gramwd{write}(#1,#2)}
\newcommand{\FINISH}[1]{\gramwd{finish}(#1)}
\newcommand{\READTAG}[1]{\gramwd{read}(#1)}
\newcommand{\STARTV}[1]{\gramwd{start}(#1)}
\newcommand{\ENDV}[1]{\gramwd{end}(#1)}
\newcommand{\skeywd}[1]{#1}
\newcommand{\keywd}[1]{\; {#1} \;}
\newcommand{\keywdr}[1]{\; {#1}_1 \ldots {#1}_n \;}
\newcommand{\gramwd}[1]{\; \texttt{#1} \;}
\newcommand{\sgramwd}[1]{\texttt{#1}}
\newcommand{\sumtype}[2]{\; {#1} \; + \; {#2} \;}
\newcommand{\pairtype}[2]{\; {#1}, {#2} \;}
\newcommand{\dicttype}[1]{\; dictionary(#1)\;}
\newcommand{\case}[2]{\gramwd{case}\; #1\; \gramwd{of}\; #2 \;}
\newcommand{\pcasesym}{\gramwd{switch}}
\newcommand{\pcase}[2]{\pcasesym{}\; #1\; \gramwd{of}\; #2 \;}
\newcommand{\pair}[2]{\; ({#1} \,,\, {#2}) \;}
\newcommand{\fst}[1]{\; \gramwd{fst} \; {#1} \;}
\newcommand{\snd}[1]{\; \gramwd{snd} \; {#1} \;}
\newcommand{\bind}[2]{{#1} \Rightarrow {#2}}
\newcommand{\inl}[1]{\; \gramwd{inl} \; #1 \;}
\newcommand{\inr}[1]{\; \gramwd{inr} \; #1 \;}
\newcommand{\fun}[2]{\; \lambda {#1} . {#2} \;}
\newcommand{\var}{\; \svar \;}
\newcommand{\svar}{v}
\newcommand{\fvar}{\; \sfvar \;}
\newcommand{\sfvar}{f}
\newcommand{\num}{\; n \;}
\newcommand{\primexpr}[1]{\; \PRIM(#1) \;}
\newcommand{\letexpr}[3]{\;\gramwd{let} \; #1 = #2 \; \gramwd{in} \; #3 \;}
\newcommand{\letexprb}[3]{\; & \gramwd{let} & \; #1 = #2 \; \gramwd{in} \; \\ #3 \;}
\newcommand{\ife}[3]{\; \gramwd{if}#1\gramwd{then}#2\gramwd{else}#3 \;}
\newcommand{\app}[2]{\; #1(#2) \;}
\newcommand{\mapp}[3]{\; #1\;[\,#2\,]\;(\,#3\,) \;}
\newcommand{\return}[2]{\; \gramwd{return}\;[\,#1\,]\;#2\;}
\newcommand{\returnb}[2]{\; & \gramwd{return}\; [\,#1\,]\;#2\;& \\}
\newcommand{\project}[2]{\; \gramwd{prj}_{#1}\,{#2}\;}
\newcommand{\anonfun}[2]{\; \lambda\,(#1)\,.\,#2\;}
\newcommand{\letlexpr}[4]{\;\gramwd{let} \; [\,#1\,]\; #2 = #3 \; \gramwd{in} \; #3 \;}
\newcommand{\letlexprb}[4]{\;&\gramwd{let}\; [\,#1\,]\; #2 = #3 \; \gramwd{in}& \; \\ #4 \;}
\newcommand{\letregion}[2]{\; \gramwd{letregion}\;#1\; \gramwd{in}\; #2 \;}
\newcommand{\letregionb}[2]{\; & \gramwd{letregion}\; #1\; \gramwd{in}\;& \\ #2 \;}
\newcommand{\mkdata}[3]{\; #1\;#2\;\;#3 \;}
\newcommand{\LOC}{\keywd{\iota}}
\newcommand{\REG}{\keywd{r}}
\newcommand{\atloc}[1]{@#1}
\newcommand{\lstart}[1]{\; \gramwd{start}(#1) \;}
\newcommand{\CONSTR}{\keywd{C}}
\newcommand{\A}{\keywd{A}}
\newcommand{\casetag}[3]{\; \gramwd{caseTag}\;#1\;\gramwd{of}\;(#2 \rightarrow #3)\;}

\begin{document}
\maketitle

%% \section{Grammar from paper (first order)}

%% \begin{displaymath}
%%     \DC \in \; \textup{Data Constructors}, \:\: \TC \in \; \textup{Type Constructors}, \:\: \var \in \; \textup{Variables}
%% \end{displaymath} 
%% \begin{displaymath}
%%     \begin{aligned}
%%       \textup{Program} && \PROG && \gramdef & \DD_1 \ldots \DD_n \; ; 
%%                           \VD_1 \ldots \VD_m \; ; \FD_1 \ldots \FD_m \; ; \EXPR \\
%%       \textup{Packed Data Declarations} && \DD && \gramdef & \DATA \TC = \overline{[\DC \; \overline{\sTYP}\;]} \\
%%       \textup{Value Declarations}    && \VD && \gramdef & \var : \TYP  ; \var = \EXPR \\ 
%%       \textup{Function Declarations} && \FD && \gramdef & \fvar : \TYP ; \fvar(\var) = \EXPR \\ 
%%       \textup{Expressions} && \EXPR && \gramdef & \var \gramor \num \gramor \gramwd{True} \gramor \gramwd{False}
%%                                   \gramor \primexpr{\overline{\sEXPR}} \gramor 
%%        \app{f}{\sEXPR} \\
%%       && && \gramor & 
%%       %    \pair{\sEXPR}{\sEXPR} \gramor \fst{e} \gramor \snd{e}
%%       \;(e_1,\, \dots\, , e_n)\; \gramor \EXPR.\num 
%%       \gramor \letexpr{\var:\TYP}{\EXPR}{\EXPR} \\
%%       && && \gramor & \case{\sEXPR}{\overline{[\bind{\DC \; \overline{\svar} \;}{\EXPR}]}} \gramor  \ife{\EXPR}{\EXPR}{\EXPR} \\
%%       \textup{Types} && \TYP && \gramdef &
%%       \TC \gramor \pairtype{\TYP}{\TYP} \gramor \TYP \ARROW \TYP
%%       \gramor \gramwd{Int} \gramor \gramwd{Bool} \gramor \dots
%%       \\
%%       %% && && \gramor & \NEEDS{[\overline{\sTYP}]}{\sTYP} \gramor \HAS{\sTYP} \\
%%       \textup{Prim Ops} && \PRIM && \gramdef & + \gramor - \gramor * \gramor \ldots \\
%%     \end{aligned}
%% \end{displaymath}

\section{Region+Location Calculus}
\subsection{Grammar}
\begin{displaymath}
    \DC \in \; \textup{Data Constructors}, \:\: \TC \in \; \textup{Type Constructors}, \:\: \var \in \; \textup{Variables}
\end{displaymath} 
\begin{displaymath}
  \begin{aligned}
      \textup{Program} && \PROG && \gramdef & \DD_1 \ldots \DD_n \; ; 
                          %% \VD_1 \ldots \VD_m \; ;
                          \FD_1 \ldots \FD_m \; ; \EXPR \\
      \textup{Packed Data Declarations} && \DD && \gramdef & \DATA \TC = \overline{[\DC \; \overline{\sTYP}\;]} \\    
      %% \textup{Value Declarations}    && \VD && \gramdef & \var : \TYP  ; \var = \EXPR \\
      \textup{Function Declarations} && \FD && \gramdef & \fvar : \STYP ; \fvar(\overline{\var}) = \EXPR \\
      \textup{Primitives} && \PRIM && \gramdef & + \gramor - \gramor * \gramor \ldots \\
      \textup{Expressions} && \EXPR && \gramdef & \var \gramor \num \gramor \gramwd{True} \gramor \gramwd{False} \gramor
            \primexpr{\overline{\sEXPR}} \gramor \mapp{\fvar}{\overline{\LOC}}{\overline{\EXPR}} \\
      && && \gramor & \letlexpr{\overline{\LOC}}{\var:\TYP}{\EXPR}{\EXPR} \\
      && && \gramor & \;(e_1,\, \dots\, , e_n)\; \gramor \project{\num}{\EXPR} \\
      && && \gramor & \return{\overline{\LOC}}{\EXPR} \gramor \ife{\EXPR}{\EXPR}{\EXPR} \\
      && && \gramor & \letregion{\REG}{\EXPR} \\
      && && \gramor & \mkdata{\DC}{\atloc{\LOC}}{\overline{\EXPR}} \gramor \case{\sEXPR}{\overline{[\bind{\DC \; \overline{\svar} \;}{\EXPR}]}} \\
      \textup{Locations} && \LOC && \gramdef & \LOC_1 \gramor \LOC_2 \gramor \ldots \gramor \lstart{\REG} \\
      \textup{Type Schemas} && \STYP && \gramdef & \forall\;\overline{\LOC}\;.\;\overline{\TYP}\rightarrow\TYP \\
      \textup{Types} && \TYP && \gramdef & \TC_{\LOC} \gramor \pairtype{\TYP}{\TYP} \gramor \gramwd{Int} \gramor \gramwd{Bool} \\
      \textup{Constraints} && \CONSTR && \gramdef & \LOC \equiv^{\LOC} \LOC + \A \\
      \textup{Arithmetic} && \A && \gramdef & \num \gramor \{ c\, |\, c \, \leq \num \}
  \end{aligned}
\end{displaymath}
\subsection{Example}
\begin{displaymath}
\begin{aligned}
\letregionb{p_1}
  {\letlexprb{li_1}{t_1}{\gramwd{buildTree}[\gramwd{startR}(p_1)] 10}
    {\letlexprb{li_1,lo_3}{t_2}{\gramwd{add1}[\gramwd{startR}(p_1),\gramwd{startW}(p_2)] t_1}
      {\returnb{a}{t_2}}}}
\end{aligned}
\end{displaymath}

\section{Target Language}
\subsection{Grammar}
\begin{displaymath}
  \begin{aligned}
      \textup{Program} && \PROG && \gramdef & \FD_1 \ldots \FD_m \; ; \EXPR \\
      \textup{Function Declarations} && \FD && \gramdef & \fvar(\overline{\var:\TYP}) : \TYP = \EXPR \\
      \textup{Expressions} && \EXPR && \gramdef & \var \gramor \num \gramor \gramwd{Tag}\num \\
      && && \gramor & \fvar \overline{\EXPR} \\
      && && \gramor & \ife{\EXPR}{\EXPR}{\EXPR} \gramor \gramwd{True} \gramor \gramwd{False} \\
      && && \gramor & \letexpr{\var:\TYP}{\EXPR}{\EXPR} \\
      && && \gramor & \;(e_1,\, \dots\, , e_n)\; \gramor \project{\num}{\EXPR} \\
      && && \gramor & \letregion{\REG}{\EXPR} \gramor \gramwd{startR}(\REG) \gramor \gramwd{startW}(\REG) \\
      && && \gramor & \casetag{\EXPR}{\gramwd{Tag}\num \;\& \var}{\EXPR} \\
      && && \gramor & \gramwd{readInt} \var \gramor \gramwd{writeInt} \var \EXPR \\
      && && \gramor & \gramwd{readTag} \var \gramor \gramwd{writeTag} \var \EXPR \\
      \textup{Types} && \TYP && \gramdef & \gramwd{Int} \gramor \gramwd{Tag} \gramor \gramwd{OutLoc} [\,\overline{\TYP}\,] \gramor \gramwd{InLoc} [\,\overline{\TYP}\,]
  \end{aligned}
\end{displaymath}

\end{document}
