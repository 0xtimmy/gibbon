We thank the reviewers for their time and detailed feedback. We are glad that all reviewers found the topic 
of the paper interesting.

We will certainly put significant effort into improving the presentation of the technical aspects of the 
paper, as suggested by all three reviewers. In addition to adding more thorough running examples, as 
suggested by reviewer C, we will provide a more precise and rigorous presentation of the transformations 
performed by Gibbon. Reviewer C brought up specific confusion about the behavior of programs that do
not follow an in-order tree traversal, and we believe an expanded explanation of our proposed transformations
will clear this up---in the specific 'sum' example C cites, x will only need to be traversed once. 

We will add a citation for session types, and clarify their purpose in our transformation. The
Has/Need types, along with the effect types, are used internally in the Gibbon compiler as a
typing discipline, where they enforce that the traversal code reads and writes packed data
in the right order. At the point in the compiler they appear, no indirections are assumed. Reviewer
A's observation that the types would better be described as behavioral types is appreciated [do we 
agree with this? I don't know what they are].

Reviewer A mentions in-place updates to trees, which we did not discuss in the paper. We can speculate
that in-place updates may be performed in certain situations (such as when exact sizes are known, or 
when the tree's structure does not change), but we leave a full exploration of this as future work.
However, many useful programs can be expressed efficiently with immutable trees. We specifically
called out point correlation on k-d trees as a real-world example where our technique is useful.
Reviewer B points out that our evaluation focuses on relatively simple programs, so to further
strengthen the claims in our paper we will include results for less trivial tree transformations 
for the camera ready (such as [maybe?] type checking and performing capture-avoiding substitution on
Racket ASTs). Additionally, we want to point out that, in general, many real-world compiler passes
essentially boil down to either maps or folds, which motivated our choice of simple but 
representative benchmarks.

In our future work we intend to support packed trees allocated in block chains, and Reviewer A
noted that our benchmark results may benefit from the lack of this proposed feature, which is
absolutely correct. As we will clarify here and in the paper, the "bumpalloc" C code that served
as our primary comparison in the evaluation was written so as to also not pay these costs [wording?],
so that comparison is apples-to-apples. We will add a full discussion on this topic to the evaluation
section.

Reviewer A also suggests that we clarify which programs in the evaluation used indirection. 
The add1tree, sumtree, and countnodes [is that all?] benchmarks did not require any
indirections, as they were full traversals. It is actually not quite right to say that a fully
automated transformation must *always* add indirection---we discuss synthesizing code to "fill out"
traversals that may skip some subtrees. The addition of indirection in the packed representation 
is an *optimization* that applies to such incomplete traversals, to avoid doing the work of walking
through an array to consume an unused subtree. We fully agree with A that this is not clear, 
however, so we will clarify this in the evaluation, as well as provide more benchmark data on
incomplete traversals. [I'm iffy on contradicting A on this point... might not be important]
