{-# LANGUAGE TupleSections #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE CPP #-}
module TestRunner
    (main) where

import Control.Monad
import Control.Monad.Reader
import Data.Foldable
import Data.List
#if !MIN_VERSION_base(4,11,0)
import Data.Monoid
#endif
import Data.Time.LocalTime
import Data.Yaml as Y
import Options.Applicative as OA hiding (empty)
import Options.Applicative.Types (readerAsk)
import System.Clock
import System.Directory
import System.Exit
import System.FilePath
import System.IO
import System.Process
import Text.PrettyPrint hiding ((<>), Mode(..))
import Text.Printf

import qualified Data.ByteString.Char8 as BS
import qualified Data.Text as T
import qualified Data.Map as M
import qualified Data.Set as S
import qualified Text.PrettyPrint as PP

import Debug.Trace

{- TestRunner:
--------------

This is a simple script which compiles and tests the Gibbon examples.
(It might have been easier to just extend the current Makefile to
 add new features, but this Haskell script might be worth a try.)

(1) Look for tests under the root directories (examples/ and examples/error/).
    The tests under examples/error are expected to fail.

(2) Run the test.

(3) If it compiles and produces a answer, we use "diff" to check if the output
    matches the answer generated by Racket.

    (TestRunner does not generate the Racket answers. It expects the Makefile
     to do that for now.)

(4) Depending on (3), put the result in the appropriate bucket:
    - Expected pass
    - Unexpected pass
    - Expected failure
    - Unexpected failure

(5) Print out a summary at the end (and write the results to gibbon-test-summary.txt).


Note [Comparing answers]:
-------------------------
If we're running a benchmark i.e anything that produces a BATCHTIME or SELFTIMED,
the Gibbon output may not match the answer generated by Racket.
We ignore such failures for now. Later, we could add a "bench" mode, which ensures that
the delta is within some reasonable range (like nofib).

TODOs:
(1) Compare benchmark results
(2) ...

-}

--------------------------------------------------------------------------------
-- A single test

data Test = Test
    { name :: String
    , dir  :: FilePath
    , expectedResults :: M.Map Mode Result
    , skip :: Bool
    , runModes :: [Mode] -- ^ If non-empty, run this test only in the specified modes.
    }
  deriving (Show, Eq, Read)

defaultTest :: Test
defaultTest = Test
    { name = ""
    , dir = "examples"
    , expectedResults = M.fromList [(Packed, Pass), (Pointer, Pass), (Interp1, Pass)]
    , skip = False
    , runModes = []
    }

instance Ord Test where
    compare t1 t2 = compare (name t1) (name t2)

instance FromJSON Test where
    parseJSON (Y.Object o) = do
        name <- o .: "name"
        dir  <- o .:? "dir" .!= (dir defaultTest)
        skip <- o .:? "skip" .!= (skip defaultTest)
        failing <- o .:? "failing" .!= []
        runmodes <- o .:? "run-modes" .!= (runModes defaultTest)
        let expectedFailures = M.fromList [(mode, Fail) | mode <- failing]
            -- Overlay the expected failures on top of the defaults.
            expected = M.union expectedFailures (expectedResults defaultTest)
        return $ Test name dir expected skip runmodes

data Result = Pass | Fail
  deriving (Show, Eq, Read, Ord)

-- Not used atm.
-- | Gibbon mode to run programs in
data Mode = Packed | Pointer | Interp1
  deriving (Show, Eq, Read, Ord)

instance FromJSON Mode where
    parseJSON (Y.String s) = return $ readMode s

readMode :: T.Text -> Mode
readMode s =
    case T.toLower s of
        "packed"  -> Packed
        "pointer" -> Pointer
        "interp1" -> Interp1

-- Must match the flag expected by Gibbon.
modeRunOptions :: Mode -> [String]
modeRunOptions Packed  = ["--run", "--packed"]
modeRunOptions Pointer = ["--run", "--pointer"]
modeRunOptions Interp1 = ["--interp1"]

modeFileSuffix :: Mode -> String
modeFileSuffix Packed  = "_pkd"
modeFileSuffix Pointer = "_ptr"
modeFileSuffix Interp1 = "_interp1"

-- Couldn't figure out how to write a parser which accepts multiple arguments.
-- The 'many' thing cannot be used with an option. I suppose that just
-- having modes trailing at the end, or as flags is also acceptable.
-- This needs to go away soon.
-- > stringToModes packed = [Packed]
-- > stringToModes "packed, pointer" = [Packed, Pointer]
-- > stringToModes "packed, packed" = [Packed]
stringToModes :: ReadM [Mode]
stringToModes = do
    str <- readerAsk
    let txt = T.pack str
        split = T.splitOn "," txt
        clean = map T.strip split
    mapM (return . readMode) (nub clean)

-- This doesn't have to be a new datatype. But it makes parsing the YAML file easier.
-- We peel off this layer later.
data Tests = Tests [Test]
  deriving (Show, Eq, Read, Ord)

instance FromJSON Tests where
    parseJSON (Y.Object o) = do
        tests <- o .:? "tests" .!= []
        return $ Tests tests

--------------------------------------------------------------------------------
-- Test configuration

data TestConfig = TestConfig
    { skipFailing :: Bool     -- ^ Don't run the expected failures.
    , verbosity   :: Int      -- ^ Ranges from [0..5], and is passed on to Gibbon
    , summaryFile :: FilePath -- ^ File in which to store the test summary
    , tempdir     :: FilePath -- ^ Temporary directory to store the build artifacts
    , gRunModes   :: [Mode] -- ^ When not empty, only run the tests in these modes.
                            --   It's a global parameter i.e it affects ALL tests.
                            --   However, if a corresponding parameter is specified
                            --   for a particular test, that has higher precedence.
    }
  deriving (Show, Eq, Read, Ord)

defaultTestConfig :: TestConfig
defaultTestConfig = TestConfig
    { skipFailing = False
    , verbosity   = 1
    , summaryFile = "gibbon-test-summary.txt"
    , tempdir     = "examples/build_tmp"
    , gRunModes   = []
    }

instance FromJSON TestConfig where
    parseJSON (Y.Object o) = TestConfig <$>
                                 o .:? "skip-failing" .!= (skipFailing defaultTestConfig) <*>
                                 o .:? "verbosity"    .!= (verbosity defaultTestConfig)   <*>
                                 o .:? "summary-file" .!= (summaryFile defaultTestConfig) <*>
                                 o .:? "tempdir"      .!= (tempdir defaultTestConfig)     <*>
                                 o .:? "run-modes"    .!= (gRunModes defaultTestConfig)

-- Accept a default test config as a fallback, either 'DefaultTestConfig',
-- or read from the config file.
configParser :: TestConfig -> OA.Parser TestConfig
configParser dtc = TestConfig
                   <$> switch (long "skip-failing" <>
                               help "Skip tests in the error/ directory." <>
                               showDefault)
                   <*> option auto (short 'v' <>
                                    help "Verbosity level." <>
                                    showDefault <>
                                    value (verbosity dtc))
                   <*> strOption (long "summary-file" <>
                                  help "File in which to store the test summary" <>
                                  showDefault <>
                                  value (summaryFile dtc))
                   <*> strOption (long "tempdir" <>
                                  help "Temporary directory to store the build artifacts" <>
                                  showDefault <>
                                  value (tempdir dtc))
                   -- TODO: actually parse this
                   <*> option stringToModes (long "run-modes" <>
                                             help "Only run the tests in these modes" <>
                                             value (gRunModes dtc))

--------------------------------------------------------------------------------

-- | Details related to a single run of the testsuite.
data TestRun = TestRun
    { tests :: [Test]
    , startTime :: TimeSpec
    , expectedPasses :: M.Map String [Mode]
    , unexpectedPasses :: M.Map String [Mode]
    , expectedFailures :: M.Map String [(Mode, String)]
    , unexpectedFailures :: M.Map String [(Mode, String)]
    , skipped :: [String]
    }
  deriving (Show, Eq, Read, Ord)

clk :: Clock
clk = RealtimeCoarse

getTestRun :: Tests -> IO TestRun
getTestRun (Tests tests) = do
    time <- getTime clk
    return $ TestRun
        { tests = tests
        , startTime = time
        , expectedPasses = M.empty
        , unexpectedPasses = M.empty
        , expectedFailures = M.empty
        , unexpectedFailures = M.empty
        , skipped = []
        }

--------------------------------------------------------------------------------
-- The main event

-- This should probably be called ActualTestResult to make it separate from 'Result'.
data TestResult
    = EP -- ^ Expected pass
    | UP -- ^ Unexpected pass
    | EF String -- ^ Expected failure
    | UF String -- ^ Unexpected failure
  deriving (Eq, Read, Ord)

instance Show TestResult where
    show EP = "Expected pass"
    show UP = "Unexpected pass"
    show (EF s) = "Expected failure\n" ++ s
    show (UF s) = "Unexpected failure\n" ++ s

runTests :: TestConfig -> TestRun -> IO TestRun
runTests tc tr = foldlM (\acc t -> do
                             -- putStrLn (name t)
                             putStr "."
                             go t acc)
                 tr (sort $ tests tr)
  where
    go test acc =
        if skip test
        then return (acc { skipped = (name test):(skipped acc) })
        else do
            -- Check if the global gRunModes or the test specific runModes was modified
            let allModes = [Packed, Pointer, Interp1]
                test' = case (runModes test, gRunModes tc) of
                            -- Nothing was globally modified
                            (_,[])  -> test { runModes = allModes }
                            -- The tests doesn't specify an override, but there's a global override
                            ([],ms) -> test { runModes = ms }
                            -- There's a global override, but the one specified for a test
                            -- has higher precedence
                            _ -> test { runModes = allModes }
            results <- runTest tc test'
            let extend = M.insertWith (++) (name test')
            foldrM
                (\(mode,res) acc2 ->
                     return $ case res of
                        EP -> acc2 { expectedPasses = extend [mode] (expectedPasses acc2) }
                        UP -> acc2 { unexpectedPasses = extend [mode] (unexpectedPasses acc2) }
                        EF err -> acc2 { expectedFailures = extend [(mode,err)] (expectedFailures acc2) }
                        UF err -> acc2 { unexpectedFailures = extend [(mode,err)] (unexpectedFailures acc2) })
                acc results

runTest :: TestConfig -> Test -> IO [(Mode,TestResult)]
runTest tc Test{name,dir,expectedResults,runModes} =
    mapM (\(m,e) -> go m e) (M.toList $ M.restrictKeys expectedResults (S.fromList runModes))
  where
    go :: Mode -> Result -> IO (Mode, TestResult)
    go mode expected = do
        (_, Just hout, Just herr, phandle) <-
            createProcess (proc cmd options) { std_out = CreatePipe
                                             , std_err = CreatePipe }
        exitCode <- waitForProcess phandle
        case exitCode of
            ExitSuccess -> do
                -- Write the output to a file
                out <- hGetContents hout
                writeFile outpath out
                -- Diff the output and the answer
                actual <- diff anspath outpath
                case (actual, expected) of
                    -- Nothing == No difference between the expected and actual answers
                    (Nothing, Pass) -> return (mode, EP)
                    (Nothing, Fail) -> return (mode, UP)
                    (Just d , Fail) -> return (mode, EF d)
                    (Just d , Pass) -> return (mode, UF d)
            ExitFailure _ -> do
                case expected of
                    Fail -> (mode,) <$> EF <$> hGetContents herr
                    Pass -> (mode,) <$> UF <$> hGetContents herr
      where
        tmppath  = tempdir tc </> name
        basename = replaceBaseName tmppath (takeBaseName tmppath ++ modeFileSuffix mode)
        outpath  = replaceExtension basename ".out"
        anspath  = replaceExtension tmppath ".ans"
        cpath    = replaceExtension basename ".c"
        exepath  = replaceExtension basename ".exe"

        cmd = "gibbon"
        options =
            modeRunOptions mode ++ [ "--cfile=" ++ cpath , "--exefile=" ++ exepath , dir </> name ]

--------------------------------------------------------------------------------

diff :: FilePath -> FilePath -> IO (Maybe String)
diff a b = do
    (_, Just hout, _, phandle) <-
        -- Ignore whitespace
        createProcess (proc "diff" ["-w", a, b])
            { std_out = CreatePipe
            , std_err = CreatePipe }
    exitCode <- waitForProcess phandle
    case exitCode of
        ExitSuccess -> return Nothing
        ExitFailure _ -> do
            d <- hGetContents hout
            -- See Note [Comparing answers]
            if isBenchOutput d
            then return Nothing
            else return (Just d)

isBenchOutput :: String -> Bool
isBenchOutput s = isInfixOf "BATCHTIME" s || isInfixOf "SELFTIMED" s

summary :: TestConfig -> TestRun -> IO String
summary tc tr = do
    endTime <- getTime clk
    day <- getZonedTime
    let timeTaken = quot (toNanoSecs (diffTimeSpec endTime (startTime tr))) (10^9)
    return $ render (go timeTaken day)
  where
    hline x = text "--------------------------------------------------------------------------------" $$ x

    fixedWidthText str = text (printf "%-25s" str)

    docNameModes name modes = fixedWidthText name <+> colon <+> (hsep $ punctuate comma (map sdoc modes))

    docErrors ls =
        vcat (map (\(name,m_errors) ->
                       (if (verbosity tc) >= 3
                        then hang (fixedWidthText name <> colon) 2
                                  (vcat (map (\(m,err) -> hang (sdoc m <> colon) 2 (text err)) m_errors))
                        else docNameModes name (map fst m_errors)))
                  ls)

    go :: (Num a, Show a) => a -> ZonedTime -> Doc
    go timeTaken day =
        text "Gibbon testsuite summary: " <+> parens (text $ show day) $$
        text "--------------------------------------------------------------------------------" $$
        text "Time taken:" <+> text (show timeTaken) PP.<> text "s" $$
        text "" $$
        (int $ length $ expectedPasses tr) <+> text "expected passes"  $$
        (int $ length $ unexpectedPasses tr) <+> text "unexpected passes" $$
        (int $ length $ expectedFailures tr) <+> text "expected failures" $$
        (int $ length $ unexpectedFailures tr) <+> text "unexpected failures" $$
        (int $ length $ skipped tr) <+> text "skipped" $$
        (case skipped tr of
             [] -> empty
             ls -> if (verbosity tc) >= 2
                   then text "\nSkipped: " $$ hline (hsep $ punctuate comma (map text ls))
                   else empty) $$
        (case M.toList (unexpectedPasses tr) of
             [] -> empty
             ls -> text "\nUnexpected passes:" $$
                   hline (vcat (map (\(name,modes) -> docNameModes name modes) ls))) $$
        (case M.toList (unexpectedFailures tr) of
            [] -> empty
            ls -> text "\nUnexpected failures:" $$ hline (docErrors ls)) $$
        (case M.toList (expectedFailures tr) of
             [] -> if skipFailing tc
                   then text "Expected failures: skipped."
                   else empty
             ls -> if (verbosity tc) >= 3
                   then text "\nExpected failures:" $$ hline (docErrors ls)
                   else empty)

sdoc :: Show a => a -> Doc
sdoc = text . show

configFile :: String
configFile = "tests/config.yaml"

main :: IO ()
main = do
    -- Parse the config file
    configstr <- readFile configFile
    let mb_tc :: Maybe TestConfig
        mb_tc = Y.decode (BS.pack configstr)

        mb_tests :: Maybe Tests
        mb_tests = Y.decode (BS.pack configstr)

    case (mb_tc, mb_tests) of
        (Nothing,_) -> error $ "Couldn't parse the configuration in " ++ configFile
        (_,Nothing) -> error $ "Couldn't parse the tests in " ++ configFile
        (Just file_tc, Just tests) -> do
            -- Combine the options read from the config file with the command line
            -- arguments (which have higher precedence).
            let opts = info (configParser file_tc <**> helper)
                           (fullDesc
                            <> header "TestRunner - a simple harnness for the Gibbon testsuite.")
            tc <- execParser opts
            test_run <- getTestRun tests
            test_run' <- runTests tc test_run
            report <- summary tc test_run'
            writeFile (summaryFile tc) report
            putStrLn $ "\nWrote " ++ (summaryFile tc) ++ "."
            putStrLn $ "\n\n" ++ report
            unless (M.null (unexpectedFailures test_run') && M.null (unexpectedPasses test_run'))
                exitFailure
